import { DISCRIMINATOR_SIZE, IdlEvents, utils } from "@coral-xyz/anchor";
import {
  JUPITER_PERPETUALS_PROGRAM,
  RPC_CONNECTION,
  USDC_DECIMALS,
  CUSTODY_PUBKEY,
  JLP_POOL_ACCOUNT_PUBKEY,
  JUPITER_PERPETUALS_PROGRAM_ID,
  CUSTODY_PUBKEYS,
} from "./constants";
import { PublicKey } from "@solana/web3.js";
import { Perpetuals } from "./idl/jupiter-perpetuals-idl";
import { BN } from "@coral-xyz/anchor";
import { BNToUSDRepresentation } from "./utils";

// Position PDA generation functions (imported from generate-position-and-position-request-pda.ts)
function generatePositionPda({
  custody,
  collateralCustody,
  walletAddress,
  side,
}: {
  custody: PublicKey;
  collateralCustody: PublicKey;
  walletAddress: PublicKey;
  side: "long" | "short";
}) {
  const [position, bump] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("position"),
      walletAddress.toBuffer(),
      JLP_POOL_ACCOUNT_PUBKEY.toBuffer(),
      custody.toBuffer(),
      collateralCustody.toBuffer(),
      // @ts-ignore
      side === "long" ? [1] : [2], // This is due to how the `Side` enum is structured in the contract
    ],
    JUPITER_PERPETUALS_PROGRAM_ID,
  );

  return { position, bump };
}

// Helper function to get asset name from custody pubkey
function getAssetNameFromCustodyPda(custodyPubkey: string): string {
  switch(custodyPubkey) {
    case CUSTODY_PUBKEY.SOL:
      return "SOL";
    case CUSTODY_PUBKEY.ETH:
      return "ETH";
    case CUSTODY_PUBKEY.BTC:
      return "BTC";
    case CUSTODY_PUBKEY.USDC:
      return "USDC";
    case CUSTODY_PUBKEY.USDT:
      return "USDT";
    default:
      return "Unknown";
  }
}

// Generate deterministic 5-character alphanumeric trade ID
function generateTradeId(positionKey: string, firstEventTimestamp: string): string {
  // Step 1: Combine position key + timestamp into one string
  const source = `${positionKey}${firstEventTimestamp}`;
  // Example: "76USLRvRMwDoGsK2Bj4RXV2CnuAUxgpVhJy7496Fz4M12025-06-05T14:38:45.000Z"
  
  let hash = 0;
  
  // Step 2: Loop through each character and create a numeric hash
  for (let i = 0; i < source.length; i++) {
    // Get ASCII code of character (e.g., 'A' = 65, '1' = 49)
    const charCode = source.charCodeAt(i);
    
    // Mathematical formula to create hash:
    // - Shift hash left by 5 bits (multiply by 32)
    // - Subtract original hash 
    // - Add character code
    // - Keep result as 32-bit integer
    hash = ((hash << 5) - hash + charCode) & 0xffffffff;
  }
  
  // Step 3: Convert negative numbers to positive
  const positiveHash = Math.abs(hash);
  // Example: 1847392847
  
  // Step 4: Convert to base36 (uses 0-9 and a-z = 36 characters)
  const base36 = positiveHash.toString(36);
  // Example: "q7k9m2x"
  
  // Step 5: Take last 5 characters and make uppercase
  return base36.slice(-5).toUpperCase();
  // Example: "Q7K9M"
}

// Generate all possible position PDAs for a wallet
function generateAllPositionPdas(walletAddress: string) {

  
  try {
    const walletPubkey = new PublicKey(walletAddress);

    
    // Results container
    const results: Array<{
      type: string;
      positionPda: PublicKey;
      description: string;
    }> = [];
    

    
    // Loop through all custodies (SOL, BTC, ETH)
    for (let i = 0; i < 3; i++) {
      const assetCustody = CUSTODY_PUBKEYS[i];
      const assetName = getAssetNameFromCustodyPda(assetCustody.toBase58());
      

      
      // Generate Long position PDA
      const longPosition = generatePositionPda({
        custody: assetCustody,
        collateralCustody: assetCustody, // For long, custody and collateralCustody are the same
        walletAddress: walletPubkey,
        side: "long",
      });
      
      results.push({
        type: "Long",
        positionPda: longPosition.position,
        description: `Long ${assetName} (using USDC as collateral)`,
      });
      

      
      // Generate Short position PDAs with different collateral types (USDC and USDT)

      for (let j = 3; j < 5; j++) { // USDC and USDT are at index 3 and 4
        const stableCustody = CUSTODY_PUBKEYS[j];
        const stableName = getAssetNameFromCustodyPda(stableCustody.toBase58());
        

        
        const shortPosition = generatePositionPda({
          custody: assetCustody,
          collateralCustody: stableCustody,
          walletAddress: walletPubkey,
          side: "short",
        });
        
        results.push({
          type: "Short",
          positionPda: shortPosition.position,
          description: `Short ${assetName} (using ${stableName} as collateral)`,
        });
        

      }
    }
    

    
    return results;
  } catch (error) {

    throw error;
  }
}

type AnchorIdlEvent<EventName extends keyof IdlEvents<Perpetuals>> = {
  name: EventName;
  data: IdlEvents<Perpetuals>[EventName];
};

// EventWithTx combines an event with its transaction data
type EventWithTx = {
  event: {
    name: string;
    data: any;
  } | null;
  tx: {
    signature: string;
    blockTime: string | null;
    slot?: number;
    fee: string;
    feeInLamports: number;
  };
} | null;  // Make nullable to match actual return type

// Trade represents a complete trade lifecycle
interface ITrade {
  id: string; // unique ID combining positionKey and lifecycle count
  positionKey: string;
  positionSide: string; // "Long" or "Short"
  status: "active" | "closed" | "liquidated";
  owner: string;
  asset?: string;
  entryPrice: number;
  exitPrice?: number;
  sizeUsd: number;
  finalSize?: number; // Size before closing (for completed trades)
  maxSize?: number;   // Maximum size the position reached
  collateralUsd: number;
  leverage: number;
  pnl?: number;
  roi?: number;
  totalFees?: number; // Total fees paid for the position
  openTime: string | null;
  closeTime?: string | null;
  events: EventWithTx[];
  hasProfit?: boolean;
}

// First, update the discriminators to match the standard Anchor format
export const TPSL_INSTRUCTION_DISCRIMINATORS = {
  // For Anchor programs, the instruction discriminator is first 8 bytes of sha256 hash of the instruction name
  instantCreateTpsl: Buffer.from([117, 98, 66, 127, 30, 50, 73, 185]), // Known discriminator from our debug output
  instantUpdateTpsl: Buffer.from([144, 228, 114, 37, 165, 242, 111, 101])  // Found from debug output
};

// Add discriminators for limit order instructions
export const LIMIT_ORDER_INSTRUCTION_DISCRIMINATORS = {
  instantCreateLimitOrder: Buffer.from([]), // Will be populated from debug if found
  instantUpdateLimitOrder: Buffer.from([])  // Will be populated from debug if found
};


// Helper function to format event data to make it human-readable
function formatEventData(event: any): any {
  if (!event) return null;
  
  const { name, data } = event;
  
  // Create a new clean object instead of modifying the original
  const cleanData: any = {};
  
  // Convert PublicKeys to strings and format numbers
  Object.keys(data).forEach(key => {
    const value = data[key];
    
    // Handle PublicKey objects
    if (value instanceof PublicKey) {
      cleanData[key] = value.toString();
    }
    // Handle BigNumbers (BN)
    else if (value instanceof BN) {
      if (key.includes('Usd') || key.includes('usd') || key.includes('Price') || key.includes('price') || key === 'pnlDelta') {
        cleanData[key] = `$${BNToUSDRepresentation(value, USDC_DECIMALS)}`;
      } else if (key.includes('Time')) {
        cleanData[key] = new Date(value.toNumber() * 1000).toISOString();
      } else {
        cleanData[key] = value.toString();
      }
    }
    // Handle arrays
    else if (Array.isArray(value)) {
      cleanData[key] = value;
    }
    // Handle side enum
    else if (key === 'positionSide') {
      cleanData[key] = value === 1 ? "Long" : "Short";
    }
    // Handle null values
    else if (value === null) {
      cleanData[key] = null;
    }
    // Handle regular values
    else {
      cleanData[key] = value;
    }
  });
  
  return {
    name,
    data: cleanData
  };
}

// Helper function to parse date in DD.MM.YYYY format
function parseDate(dateString: string): Date {
  const [day, month, year] = dateString.split('.').map(Number);
  return new Date(year, month - 1, day); // month is 0-indexed in JS Date
}

// Helper function to check if we should continue fetching based on date range
function shouldContinueFetching(blockTime: number | null, fromDate: Date): boolean {
  if (!blockTime) return true; // If no blockTime, continue fetching
  const txDate = new Date(blockTime * 1000);
  return txDate >= fromDate; // Continue while transaction date is newer than or equal to FROM_DATE
}

// Helper function to check if transaction is within date range
function isWithinDateRange(blockTime: number | null, fromDate: Date, toDate: Date): boolean {
  if (!blockTime) return false; // Skip transactions without blockTime
  const txDate = new Date(blockTime * 1000);
  return txDate >= fromDate && txDate <= toDate; // Transaction must be between FROM_DATE and TO_DATE
}

export async function getPositionEvents(fromDateString?: string, walletAddress?: string, toDateString?: string) {
  // Default wallet address if not provided
  const defaultWalletAddress = "CZKPYBkGXg1G6W8EXLxHDLRwsYtMz8TBk1qfPgCMzxG1";
  const wallet = walletAddress || defaultWalletAddress;
  
  // Generate all possible position PDAs for the wallet

  
  const positionPdas = generateAllPositionPdas(wallet);

  
  if (positionPdas.length === 0) {

    return [];
  }
  

  
  // Parse to date (default to "now" if not provided) - this is the ending point (newer date)
  const toDate = toDateString 
    ? parseDate(toDateString)
    : new Date(); // Current moment
    
  // Parse from date (default to 30 days ago if not provided) - this is the starting point (older date)
  const fromDate = fromDateString 
    ? parseDate(fromDateString)
    : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days ago
  

  
  // Validate date range
  if (fromDate >= toDate) {
    throw new Error(`FROM_DATE (${fromDate.toLocaleDateString('en-GB')}) must be older than TO_DATE (${toDate.toLocaleDateString('en-GB')})`);
  }
  

  
  // Collect all events from all PDAs
  const allEvents: any[] = [];
  
      // Process each PDA
  for (let pdaIndex = 0; pdaIndex < positionPdas.length; pdaIndex++) {
    const currentPda = positionPdas[pdaIndex];


      
      // Add delay between PDA processing to avoid rate limits
      if (pdaIndex > 0) {
        await new Promise(resolve => setTimeout(resolve, 30)); // Added small delay to avoid rate limiting
      }
    
    const allSignatures: any[] = [];
    let beforeSignature: string | undefined = undefined;
    let hasMoreTransactions = true;
    let totalFetched = 0;
    
    // Fetch transactions in batches until we reach the target date
      
    while (hasMoreTransactions && totalFetched < 1000) { // Safety limit of 1000 transactions per PDA
      const options: any = { limit: 300 }; // Sweet spot between 200 and 500 for optimal performance
      if (beforeSignature) {
        options.before = beforeSignature;

      } else {

      }
      
              const confirmedSignatureInfos = await getSignaturesWithRetry(currentPda.positionPda, options);

        if (!confirmedSignatureInfos || confirmedSignatureInfos.length === 0) {

          break;
        }
        
        totalFetched += confirmedSignatureInfos.length;

        
        // Add delay between signature fetching batches to avoid rate limits
        if (confirmedSignatureInfos.length === 300) {
          await new Promise(resolve => setTimeout(resolve, 30)); // Added small delay to avoid rate limiting
        }
      
      // Check if we've reached our target date and filter by date range
      for (const sigInfo of confirmedSignatureInfos) {
        const blockTime = sigInfo.blockTime ?? null;
        
                  // Stop fetching if we've gone past the target date
          if (!shouldContinueFetching(blockTime, fromDate)) {

            hasMoreTransactions = false;
            break;
          }
        
        // Only include transactions within the specified date range
        if (isWithinDateRange(blockTime, fromDate, toDate)) {
          allSignatures.push(sigInfo);
        }
      }
      
      // Set up for next batch
      if (hasMoreTransactions && confirmedSignatureInfos.length === 300) {
        beforeSignature = confirmedSignatureInfos[confirmedSignatureInfos.length - 1].signature;
      } else {
        hasMoreTransactions = false;
      }
    }

      if (allSignatures.length === 0) {
        continue; // Move to next PDA
      }
    
            // Process transactions for this PDA
        for (let i = 0; i < allSignatures.length; i++) {
          if (allSignatures[i].err) {

            continue;
          }
          
          // Add a delay between each transaction processing to avoid rate limits
          if (i > 0) {
            await new Promise(resolve => setTimeout(resolve, 30)); // Added small delay to avoid rate limiting
          }
          
          try {

        
        // Use our retry function
        const tx = await fetchTransactionWithRetry(allSignatures[i].signature);
        
                    if (!tx || !tx.meta || !tx.meta.innerInstructions) {

              continue;
            }
        
        const txEvents = tx.meta.innerInstructions.flatMap((ix: { instructions: any[] }) => {
          return ix.instructions.map((iix: { data: string }) => {
            try {
              const ixData = utils.bytes.bs58.decode(iix.data);
              const eventData = utils.bytes.base64.encode(
                ixData.subarray(DISCRIMINATOR_SIZE)
              );
              const decodedEvent = JUPITER_PERPETUALS_PROGRAM.coder.events.decode(eventData);
              
                              // Debugging: Log event names
                // if (decodedEvent) {

                // }
              
              // Format the event data for human readability
              const formattedEvent = formatEventData(decodedEvent);
              
              // Get transaction fee (safe because we already checked tx.meta != null)
              const feeInSOL = tx.meta!.fee / 1_000_000_000; // Convert lamports to SOL
              
              const eventWithTx = {
                event: formattedEvent,
                tx: {
                  signature: allSignatures[i].signature,
                  blockTime: tx.blockTime 
                    ? new Date(tx.blockTime * 1000).toISOString()
                    : null,
                  fee: `${feeInSOL} SOL`,
                  feeInLamports: tx.meta!.fee
                }
              };
              
              // For TP/SL events, fetch the instruction data immediately
              if (formattedEvent && (
                  formattedEvent.name === 'InstantCreateTpslEvent' || 
                  formattedEvent.name === 'InstantUpdateTpslEvent')
              ) {
                // We'll try to extract TP/SL parameters from the transaction
                let tpslData = null;
                try {
                  // Get all instructions in the transaction - handle versioned transactions
                  let instructions;
                  let accountKeys;
                  
                  if ('message' in tx.transaction) {
                    const message = tx.transaction.message;
                    
                    // For versioned transactions
                    if ('version' in message) {
                      // For MessageV0
                      instructions = message.compiledInstructions;
                      try {
                        // For versioned transactions with lookup tables
                        if (tx.meta?.loadedAddresses) {
                          // Use staticAccountKeys and loaded addresses
                          const staticKeys = message.staticAccountKeys || [];
                          const writableKeys = tx.meta.loadedAddresses.writable || [];
                          const readonlyKeys = tx.meta.loadedAddresses.readonly || [];
                          accountKeys = [...staticKeys, ...writableKeys, ...readonlyKeys];
                        } else {
                          accountKeys = message.staticAccountKeys || [];
                        }
                      } catch (err) {
                        // In case of error, fallback to static keys from the message
                        accountKeys = message.staticAccountKeys || [];
                      }
                    } else {
                      // For legacy transactions
                      instructions = (message as any).instructions;
                      accountKeys = (message as any).accountKeys;
                    }
                  }
                  
                  if (instructions && accountKeys) {
                    // Find the TP/SL instruction
                    for (const ix of instructions) {
                      // Skip if no programId index
                      if (ix.programIdIndex === undefined) continue;
                      
                      // Get program ID
                      const programId = accountKeys[ix.programIdIndex];
                      
                      // Check if this is a Jupiter Perpetuals instruction
                      if (programId.toString() === JUPITER_PERPETUALS_PROGRAM.programId.toString()) {
                        // Get the instruction data
                        const data = Buffer.from(ix.data);
                        
                        // Check for TP/SL instruction discriminators
                        const discriminator = data.slice(0, 8);
                        
                        const isCreateTpsl = Buffer.compare(discriminator, TPSL_INSTRUCTION_DISCRIMINATORS.instantCreateTpsl) === 0;
                        const isUpdateTpsl = Buffer.compare(discriminator, TPSL_INSTRUCTION_DISCRIMINATORS.instantUpdateTpsl) === 0;
                        
                                if (isCreateTpsl || isUpdateTpsl) {

          
          // Parse TP/SL parameters from buffer
                          const instructionDataBuffer = data.slice(8);
                          let offset = 0;
                          
                          let collateralUsdDelta, sizeUsdDelta, triggerPrice, triggerAboveThreshold, entirePosition, counter, requestTime;
                          
                          if (isCreateTpsl) {
                            // InstantCreateTpsl structure (7 fields)
                            collateralUsdDelta = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                            offset += 8;
                            
                            sizeUsdDelta = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                            offset += 8;
                            
                            triggerPrice = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                            offset += 8;
                            
                            triggerAboveThreshold = instructionDataBuffer[offset] === 1;
                            offset += 1;
                            
                            entirePosition = instructionDataBuffer[offset] === 1;
                            offset += 1;
                            
                            // Pad to 8-byte boundary for counter
                            offset = Math.ceil(offset / 8) * 8;
                            
                            counter = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                            offset += 8;
                            
                            requestTime = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                          } else {
                            // InstantUpdateTpsl structure (3 fields only)
                            // Set defaults for fields not in update
                            collateralUsdDelta = new BN(0);
                            counter = new BN(0);
                            
                            // Read the actual fields
                            sizeUsdDelta = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                            offset += 8;
                            
                            triggerPrice = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                            offset += 8;
                            
                            requestTime = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
                            
                            // For update events, determine triggerAboveThreshold from trigger price analysis
                            // This is a best-effort approach - could be improved with more context
                            // triggerAboveThreshold not available in InstantUpdateTpslParams IDL - will be retrieved from original create event
                            triggerAboveThreshold = false; // Placeholder
                            
                            // Set default for entirePosition - will be updated from original create event
                            entirePosition = false;
                          }

                          tpslData = {
                            instructionName: isCreateTpsl ? 'instantCreateTpsl' : 'instantUpdateTpsl',
                            params: {
                              collateralUsdDelta,
                              sizeUsdDelta,
                              triggerPrice,
                              triggerAboveThreshold,
                              entirePosition,
                              counter,
                              requestTime
                            }
                          };

                                    // Store original create event data for linking
          if (isCreateTpsl) {
            // For create events, we have the complete data including size percentage

                                    } else {
            // For update events, we only have the limited fields from the IDL

                          }
                          
                          // Add the instruction data to the event data
                          formattedEvent.data.tpslInstructionData = tpslData;
                          
                          // Add parsed fields to event data for easy access
                          formattedEvent.data.tpslCollateralUsdDelta = `$${BNToUSDRepresentation(collateralUsdDelta, USDC_DECIMALS)}`;
                          formattedEvent.data.tpslSizeUsdDelta = `$${BNToUSDRepresentation(sizeUsdDelta, USDC_DECIMALS)}`;
                          formattedEvent.data.tpslTriggerPrice = `$${BNToUSDRepresentation(triggerPrice, USDC_DECIMALS)}`;
                          formattedEvent.data.tpslTriggerAboveThreshold = triggerAboveThreshold;
                          formattedEvent.data.tpslEntirePosition = entirePosition;
                          formattedEvent.data.tpslCounter = counter.toString();
                          formattedEvent.data.tpslRequestTime = requestTime.toNumber() !== 0 ? 
                            new Date(requestTime.toNumber() * 1000).toISOString() : 
                            null;
                          
                          break; // Exit the loop once we find the instruction
                        }
                      }
                    }
                  }
                } catch (error) {

                }
              }
              
              return eventWithTx;
            } catch (error) {

              return null;
            }
          }).filter(Boolean);
        });
        
        allEvents.push(...txEvents);
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);

      }
    }
  }
  

  
  // Sort all events chronologically before returning
  allEvents.sort((a, b) => {
    const aTime = a?.tx.blockTime ? new Date(a.tx.blockTime).getTime() : 0;
    const bTime = b?.tx.blockTime ? new Date(b.tx.blockTime).getTime() : 0;
    return aTime - bTime;
  });
  
  // Filter to only return position events
  const filteredEvents = allEvents.filter(
    (data) =>
      data?.event?.name === "IncreasePositionEvent" ||
      data?.event?.name === "InstantIncreasePositionEvent" ||
      data?.event?.name === "DecreasePositionEvent" ||
      data?.event?.name === "InstantDecreasePositionEvent" ||
      data?.event?.name === "LiquidateFullPositionEvent" ||
      data?.event?.name === "IncreasePositionPreSwapEvent" ||
      data?.event?.name === "DecreasePositionPostSwapEvent" ||
      data?.event?.name === "InstantCreateTpslEvent" || // Add TP/SL events
      data?.event?.name === "InstantUpdateTpslEvent" || // Add TP/SL events
      data?.event?.name === "FillLimitOrderEvent"  // Add FillLimitOrderEvent as a main event
  );
  

  

  
  return filteredEvents;
}

// Add retry wrapper for getSignaturesForAddress to handle rate limits during signature fetching
async function getSignaturesWithRetry(positionPda: any, options: any, maxRetries = 3): Promise<any> {
  let retries = 0;
  let delay = 100; // Start with lower delay - 100ms
  
  // Log the request details
  const requestId = Math.random().toString(36).substring(2, 8);
  
  while (retries < maxRetries) {
    try {
      const startTime = Date.now();
      const result = await RPC_CONNECTION.getSignaturesForAddress(positionPda, options);
      const endTime = Date.now();
      

      
      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      

      
      // Check if it's a rate limit error
      if (errorMessage.includes('429') || errorMessage.includes('rate limit') || errorMessage.includes('too many requests')) {
        retries++;
        
        if (retries >= maxRetries) {

          throw error;
        }
        
        // Exponential backoff with jitter
        const jitter = Math.random() * 0.3 + 0.85; // Random between 0.85 and 1.15
        delay = Math.min(delay * 2 * jitter, 5000); // Cap at 5 seconds for signature fetching
        

        await new Promise(resolve => setTimeout(resolve, delay));
      } else {

        throw error;
      }
    }
  }
  
  // This should never be reached due to the throw in the loop, but TypeScript needs it
  throw new Error(`Failed to fetch signatures after ${maxRetries} retries`);
}

// Implement exponential backoff for RPC requests
async function fetchTransactionWithRetry(signature: string, maxRetries = 3): Promise<any> {
  let retries = 0;
  let delay = 100; // Start with lower delay - 100ms
  
  // Log the request details
  const requestId = Math.random().toString(36).substring(2, 8);
  
  while (retries < maxRetries) {
    try {
      const startTime = Date.now();
      const result = await RPC_CONNECTION.getTransaction(
        signature,
        { 
          commitment: "confirmed",
          maxSupportedTransactionVersion: 0
        }
      );
      const endTime = Date.now();
      

      
      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      

      
      // Check if it's a rate limit error
      if (errorMessage.includes('429') || errorMessage.includes('rate limit') || errorMessage.includes('too many requests')) {
        retries++;
        
        if (retries >= maxRetries) {

          throw error;
        }
        
        // Exponential backoff with jitter
        const jitter = Math.random() * 0.3 + 0.85; // Random between 0.85 and 1.15
        delay = Math.min(delay * 2 * jitter, 5000); // Cap at 5 seconds
        

        await new Promise(resolve => setTimeout(resolve, delay));
      } else {

        throw error;
      }
    }
  }
  
  // This should never be reached due to the throw in the loop, but TypeScript needs it
  throw new Error(`Failed to fetch transaction after ${maxRetries} retries`);
}

async function getTpslInstructionData(txSignature: string): Promise<any> {
  try {
    // Fetch the transaction with retry

    const tx = await fetchTransactionWithRetry(txSignature);
    
    if (!tx || !tx.transaction) {

      return null;
    }
    
    // Get all instructions in the transaction - handle versioned transactions
    let instructions;
    let accountKeys;
    
    if ('message' in tx.transaction) {
      const message = tx.transaction.message;
      
      // For versioned transactions
      if ('version' in message) {
        // For MessageV0
        instructions = message.compiledInstructions;
        try {
          // For versioned transactions with lookup tables
          if (tx.meta?.loadedAddresses) {
            // Use staticAccountKeys and loaded addresses
            const staticKeys = message.staticAccountKeys || [];
            const writableKeys = tx.meta.loadedAddresses.writable || [];
            const readonlyKeys = tx.meta.loadedAddresses.readonly || [];
            accountKeys = [...staticKeys, ...writableKeys, ...readonlyKeys];
          } else {
            accountKeys = message.staticAccountKeys || [];
          }
        } catch (err) {

          accountKeys = message.staticAccountKeys || [];
        }
      } else {
        // For legacy transactions
        instructions = (message as any).instructions;
        accountKeys = (message as any).accountKeys;
      }
    } else {

      return null;
    }
    
    if (!instructions || !accountKeys) {

      return null;
    }
    

    
    // Enhanced debugging: print some transaction information

    
    // Find the TP/SL instruction
    for (let i = 0; i < instructions.length; i++) {
      const ix = instructions[i];
      // Skip if no programId index
      if (ix.programIdIndex === undefined) continue;
      
      // Get program ID
      const programId = accountKeys[ix.programIdIndex];
      const programIdStr = programId.toString();
      
      // Check if this is a Jupiter Perpetuals instruction
      if (programIdStr === JUPITER_PERPETUALS_PROGRAM.programId.toString()) {
        try {
          // Get the instruction data
          const data = Buffer.from(ix.data);
          
          // Check the discriminator (first 8 bytes)
          const discriminator = data.slice(0, 8);
          
          const isCreateTpsl = Buffer.compare(discriminator, TPSL_INSTRUCTION_DISCRIMINATORS.instantCreateTpsl) === 0;
          const isUpdateTpsl = Buffer.compare(discriminator, TPSL_INSTRUCTION_DISCRIMINATORS.instantUpdateTpsl) === 0;
          
          if (isCreateTpsl || isUpdateTpsl) {
  
            
            // Parse TP/SL parameters from buffer
            const instructionDataBuffer = data.slice(8);
            let offset = 0;
            
            let collateralUsdDelta, sizeUsdDelta, triggerPrice, triggerAboveThreshold, entirePosition, counter, requestTime;
            
            if (isCreateTpsl) {
              // InstantCreateTpsl structure (7 fields)
              collateralUsdDelta = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
              offset += 8;
              
              sizeUsdDelta = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
              offset += 8;
              
              triggerPrice = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
              offset += 8;
              
              triggerAboveThreshold = instructionDataBuffer[offset] === 1;
              offset += 1;
              
              entirePosition = instructionDataBuffer[offset] === 1;
              offset += 1;
              
              // Pad to 8-byte boundary for counter
              offset = Math.ceil(offset / 8) * 8;
              
              counter = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
              offset += 8;
              
              requestTime = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
            } else {
              // InstantUpdateTpsl structure (3 fields only)
              // Set defaults for fields not in update
              collateralUsdDelta = new BN(0);
              counter = new BN(0);
              
              // Read the actual fields
              sizeUsdDelta = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
              offset += 8;
              
              triggerPrice = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
              offset += 8;
              
              requestTime = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');
              
              // For update events, determine triggerAboveThreshold from trigger price analysis
              // This is a best-effort approach - could be improved with more context
              // triggerAboveThreshold not available in InstantUpdateTpslParams IDL - will be retrieved from original create event
                          triggerAboveThreshold = false; // Placeholder
              
              // Set default for entirePosition - will be updated from original create event
              entirePosition = false;
            }

            const tpslData = {
              instructionName: isCreateTpsl ? 'instantCreateTpsl' : 'instantUpdateTpsl',
              params: {
                collateralUsdDelta,
                sizeUsdDelta,
                triggerPrice,
                triggerAboveThreshold,
                entirePosition,
                counter,
                requestTime
              }
            };

            // Store original create event data for linking
            if (isCreateTpsl) {
              // For create events, we have the complete data including size percentage
  
            } else {
              // For update events, we only have the limited fields from the IDL
  
            }
            
            return {
              instructionName: isCreateTpsl ? 'instantCreateTpsl' : 'instantUpdateTpsl',
              params: {
                collateralUsdDelta,
                sizeUsdDelta,
                triggerPrice,
                triggerAboveThreshold,
                entirePosition,
                counter,
                requestTime
              }
            };
          }
        } catch (err) {

          return null;
        }
      }
    }
    

    return null;
  } catch (err) {

    return null;
  }
}

/**
 * Parse limit order instruction data from transaction
 * This function fetches the transaction that contains a limit order event and decodes the instruction data using the IDL
 */
async function getLimitOrderInstructionData(txSignature: string): Promise<any> {
  try {
    // Fetch the transaction with retry

    const tx = await fetchTransactionWithRetry(txSignature);
    
    if (!tx || !tx.transaction) {
 // Commented out for performance
      return null;
    }
    
    // Get all instructions in the transaction - handle versioned transactions
    let instructions;
    let accountKeys;
    
    if ('message' in tx.transaction) {
      const message = tx.transaction.message;
      
      // For versioned transactions
      if ('version' in message) {
        // For MessageV0
        instructions = message.compiledInstructions;
        try {
          // For versioned transactions with lookup tables
          if (tx.meta?.loadedAddresses) {
            // Use staticAccountKeys and loaded addresses
            const staticKeys = message.staticAccountKeys || [];
            const writableKeys = tx.meta.loadedAddresses.writable || [];
            const readonlyKeys = tx.meta.loadedAddresses.readonly || [];
            accountKeys = [...staticKeys, ...writableKeys, ...readonlyKeys];
          } else {
            accountKeys = message.staticAccountKeys || [];
          }
        } catch (err) {

          accountKeys = message.staticAccountKeys || [];
        }
      } else {
        // For legacy transactions
        instructions = (message as any).instructions;
        accountKeys = (message as any).accountKeys;
      }
    } else {

      return null;
    }
    
    if (!instructions || !accountKeys) {

      return null;
    }
    
    // Find the limit order instruction
    for (let i = 0; i < instructions.length; i++) {
      const ix = instructions[i];
      // Skip if no programId index
      if (ix.programIdIndex === undefined) continue;
      
      // Get program ID
      const programId = accountKeys[ix.programIdIndex];
      const programIdStr = programId.toString();
      
      // Check if this is a Jupiter Perpetuals instruction
      if (programIdStr === JUPITER_PERPETUALS_PROGRAM.programId.toString()) {
        // Get the instruction data
        const data = Buffer.from(ix.data);
        
        // Check the discriminator (first 8 bytes)
        const discriminator = data.slice(0, 8);
        
        // Log discriminator if we find events for debugging
        if (data.length > 8) {
          // Check for likely limit order instructions based on name patterns
          const possibleDiscriminatorNames = [
            "instant_create_limit_order",
            "instantCreateLimitOrder",
            "instant_update_limit_order",
            "instantUpdateLimitOrder"
          ];
          
          for (const name of possibleDiscriminatorNames) {
            const calculatedDiscr = Buffer.from(utils.sha256.hash(name).slice(0, 8));
            if (Buffer.compare(discriminator, calculatedDiscr) === 0) {

              
              // If we find a match, save it for future reference
              if (name.includes("create")) {
                LIMIT_ORDER_INSTRUCTION_DISCRIMINATORS.instantCreateLimitOrder = Buffer.from(discriminator);
              } else if (name.includes("update")) {
                LIMIT_ORDER_INSTRUCTION_DISCRIMINATORS.instantUpdateLimitOrder = Buffer.from(discriminator);
              }
            }
          }
        }
        
        // Check against known discriminators
        const isCreateLimitOrder = 
          LIMIT_ORDER_INSTRUCTION_DISCRIMINATORS.instantCreateLimitOrder.length > 0 && 
          Buffer.compare(discriminator, LIMIT_ORDER_INSTRUCTION_DISCRIMINATORS.instantCreateLimitOrder) === 0;
          
        const isUpdateLimitOrder = 
          LIMIT_ORDER_INSTRUCTION_DISCRIMINATORS.instantUpdateLimitOrder.length > 0 && 
          Buffer.compare(discriminator, LIMIT_ORDER_INSTRUCTION_DISCRIMINATORS.instantUpdateLimitOrder) === 0;
        
        if (isCreateLimitOrder || isUpdateLimitOrder) {
          // This is a limit order instruction

          
          try {
            // Use Anchor's BorshCoder to decode the instruction data
            const ixName = isCreateLimitOrder ? "instantCreateLimitOrder" : "instantUpdateLimitOrder";
            const dataAfterDiscriminator = data.slice(8);
            
            try {
              // Decode the instruction data after the discriminator
              const args = JUPITER_PERPETUALS_PROGRAM.coder.types.decode(
                isCreateLimitOrder ? "InstantCreateLimitOrderParams" : "InstantUpdateLimitOrderParams", 
                dataAfterDiscriminator
              );
              
              // If we've made it here, decoding succeeded
              return {
                instructionName: ixName,
                params: args
              };
            } catch (err) {

              
              // Fallback to binary parsing if needed
              // Structure of limit order params (based on IDL):
              // Price, size, etc.
              const instructionDataBuffer = data.slice(8);

              
              // Extract common fields we expect in limit orders
              let offset = 0;
              
              // Try to extract price (u64/BN)
              if (offset + 8 <= instructionDataBuffer.length) {
                const price = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');

                offset += 8;
              }
              
              // Try to extract size (u64/BN)
              if (offset + 8 <= instructionDataBuffer.length) {
                const size = new BN(instructionDataBuffer.slice(offset, offset + 8), 'le');

              }
            }
          } catch (error) {

          }
        }
      }
    }
    
    // If we didn't find anything in the main instructions, check inner instructions
    if (tx.meta?.innerInstructions && tx.meta.innerInstructions.length > 0) {
      // Similar to TP/SL processing, look for limit order instructions in inner instructions
      // Implementation would be similar to the above code
    }
    
    return null;
  } catch (err) {

    return null;
  }
}

/**
 * Helper function to parse USD value from string format
 */
function parseUsdValue(value: string): number {
  if (!value) return 0;
  return parseFloat(value.replace('$', '').replace(',', ''));
}

/**
 * Calculate actual PnL using Jupiter's hasProfit field and absolute pnlDelta value
 * This is more reliable than price calculations since Jupiter provides the profit/loss direction
 */
function calculateActualPnl(
  hasProfit: boolean | undefined,
  pnlDelta: number
): number {
  if (hasProfit === undefined || pnlDelta === 0) {
    return 0;
  }
  
  // Use Jupiter's hasProfit field to determine the sign
  // pnlDelta is always positive, so we apply the correct sign based on hasProfit
  return hasProfit ? Math.abs(pnlDelta) : -Math.abs(pnlDelta);
}

/**
 * Group events into trades based on position lifecycle
 */
export function groupEventsIntoTrades(events: EventWithTx[]): { activeTrades: ITrade[]; completedTrades: ITrade[] } {
  // Filter out null events first
  const nonNullEvents = events.filter((evt): evt is NonNullable<EventWithTx> => evt !== null);
  
  // Sort events chronologically
  const sortedEvents = [...nonNullEvents].sort((a, b) => {
    const aTime = a.tx.blockTime ? new Date(a.tx.blockTime).getTime() : 0;
    const bTime = b.tx.blockTime ? new Date(b.tx.blockTime).getTime() : 0;
    return aTime - bTime;
  });

  // Create an array of execution events (only the main position events)
  const positionEvents = sortedEvents.filter(evt => 
    evt.event?.name === 'IncreasePositionEvent' ||
    evt.event?.name === 'DecreasePositionEvent' ||
    evt.event?.name === 'InstantIncreasePositionEvent' ||
    evt.event?.name === 'InstantDecreasePositionEvent' ||
    evt.event?.name === 'LiquidateFullPositionEvent' ||
    evt.event?.name === 'IncreasePositionPreSwapEvent' ||
    evt.event?.name === 'DecreasePositionPostSwapEvent' ||
    evt.event?.name === 'InstantCreateTpslEvent' || // Add TP/SL events
    evt.event?.name === 'InstantUpdateTpslEvent' || // Add TP/SL events
    evt.event?.name === 'FillLimitOrderEvent'  // Add FillLimitOrderEvent as a main event
  );

  // Create a map to associate auxiliary events (pre-swap, swap) with position events by timestamp
  const eventsByTimestamp: Map<string, EventWithTx[]> = new Map();
  
  // Group all events by their timestamp
  sortedEvents.forEach(evt => {
    if (evt.tx.blockTime) {
      const key = evt.tx.blockTime;
      if (!eventsByTimestamp.has(key)) {
        eventsByTimestamp.set(key, []);
      }
      eventsByTimestamp.get(key)?.push(evt);
    }
  });

  // Maps to track active trades by position key (since each position can only have one active trade)
  const activeTrades: Map<string, ITrade> = new Map();
  const completedTrades: ITrade[] = [];

  // Process each execution event
  for (const eventWithTx of positionEvents) {
    // Skip null events
    if (!eventWithTx.event) continue;
    
    const { event, tx } = eventWithTx;
    const { data, name } = event;
    
    // Get position key
    const positionKey = data.positionKey;

    // Check if we have an active trade for this position
    const activeTrade = activeTrades.get(positionKey);

    // Get all events with the same timestamp to include auxiliary events
    const allEventsAtTimestamp = eventsByTimestamp.get(tx.blockTime || '') || [];

    // Process based on event type
    if (name === 'IncreasePositionEvent' || name === 'InstantIncreasePositionEvent') {
      const sizeUsdDelta = parseUsdValue(data.sizeUsdDelta);
      const positionSizeUsd = parseUsdValue(data.positionSizeUsd);
      const collateralUsdDelta = parseUsdValue(data.collateralUsdDelta);
      const price = parseUsdValue(data.price);
      const fee = parseUsdValue(data.feeUsd || '0');
      
      // Check if this is a new position (first increase) or adding to an existing position
      if (!activeTrade) {
        // Get asset symbol from the custody address
        const assetSymbol = getAssetNameFromCustody(data.positionCustody || "");
        
        // Generate deterministic trade ID using position key and first event timestamp
        const tradeId = generateTradeId(positionKey, tx.blockTime || new Date().toISOString());
        
        // This is a new trade
        const newTrade: ITrade = {
          id: tradeId,
          positionKey,
          positionSide: data.positionSide,
          status: "active",
          owner: data.owner,
          asset: assetSymbol,
          entryPrice: price,
          sizeUsd: sizeUsdDelta,
          maxSize: sizeUsdDelta, // Initialize maxSize
          collateralUsd: collateralUsdDelta,
          leverage: sizeUsdDelta / collateralUsdDelta,
          totalFees: fee, // Track initial fee
          openTime: tx.blockTime,
          events: [],
        };
        
        // Add all events with the same timestamp (including preswap and swap events)
        newTrade.events = allEventsAtTimestamp;
        
        activeTrades.set(positionKey, newTrade);
      } else {
        // This is adding to an existing position
        const newCollateralUsd = activeTrade.collateralUsd + collateralUsdDelta;
        const newSizeUsd = activeTrade.sizeUsd + sizeUsdDelta;
        
        // Update the trade
        activeTrade.sizeUsd = newSizeUsd;
        activeTrade.maxSize = Math.max(newSizeUsd, activeTrade.maxSize || 0);
        activeTrade.collateralUsd = newCollateralUsd;
        activeTrade.leverage = newSizeUsd / newCollateralUsd;
        activeTrade.totalFees = (activeTrade.totalFees || 0) + fee; // Add to total fees
        
        // Add all events from this timestamp that aren't already in the trade's events
        allEventsAtTimestamp.forEach(evt => {
          if (evt && evt.event && evt.tx && evt.event.name) {
            // Check if this event is already in the trade's events
            const isDuplicate = activeTrade.events.some(existingEvt => 
              existingEvt?.tx.signature === evt.tx?.signature && 
              existingEvt?.event?.name === evt.event?.name
            );
            
            if (!isDuplicate) {
              activeTrade.events.push(evt);
            }
          }
        });
      }
    } else if (name === 'DecreasePositionEvent' || name === 'InstantDecreasePositionEvent') {
      const sizeUsdDelta = parseUsdValue(data.sizeUsdDelta);
      const positionSizeUsd = parseUsdValue(data.positionSizeUsd);
      const price = parseUsdValue(data.price);
      const pnlDelta = parseUsdValue(data.pnlDelta);
      const fee = parseUsdValue(data.feeUsd || '0');
      
      if (!activeTrade) {
        // We have a decrease event but no matching active trade

        continue;
      }
      
      // Add all events from this timestamp
      allEventsAtTimestamp.forEach(evt => {
        if (evt && evt.event && evt.tx && evt.event.name) {
          // Check if this event is already in the trade's events
          const isDuplicate = activeTrade.events.some(existingEvt => 
            existingEvt?.tx.signature === evt.tx?.signature && 
            existingEvt?.event?.name === evt.event?.name
          );
          
          if (!isDuplicate) {
            activeTrade.events.push(evt);
          }
        }
      });
      
      // Update the trade with the latest data
      activeTrade.exitPrice = price;
      
      // Use Jupiter's hasProfit field with the absolute pnlDelta value
      // This is more reliable than price calculations
      const actualPnlDelta = calculateActualPnl(
        data.hasProfit,
        pnlDelta
      );
      
      activeTrade.pnl = (activeTrade.pnl || 0) + actualPnlDelta;
      activeTrade.hasProfit = (activeTrade.pnl || 0) > 0;
      activeTrade.totalFees = (activeTrade.totalFees || 0) + fee; // Add to total fees
      
      // Calculate ROI based on PnL and collateral
      if (activeTrade.pnl !== undefined) {
        activeTrade.roi = (activeTrade.pnl / activeTrade.collateralUsd) * 100;
      }
      
      // Check if position is fully closed
      if (positionSizeUsd === 0) {
        // Store the maximum size the position reached, not just the last decrease
        activeTrade.finalSize = activeTrade.maxSize || activeTrade.sizeUsd + sizeUsdDelta;
        
        // This position is fully closed - move it to completed trades
        activeTrade.status = "closed";
        activeTrade.closeTime = tx.blockTime;
        activeTrade.sizeUsd = 0; // Set size to 0 as it's fully closed
        
        completedTrades.push({ ...activeTrade });
        activeTrades.delete(positionKey);
      } else {
        // This is a partial decrease
        activeTrade.sizeUsd -= sizeUsdDelta;
      }
    } else if (name === 'LiquidateFullPositionEvent') {
      const price = parseUsdValue(data.price);
      const pnlDelta = parseUsdValue(data.pnlDelta);
      const fee = parseUsdValue(data.feeUsd || '0');  // Extract fee from liquidation event
      const liquidationFee = parseUsdValue(data.liquidationFeeUsd || '0');
      
      if (!activeTrade) {
        // We have a liquidation event but no matching active trade

        continue;
      }
      
      // Add all events from this timestamp
      allEventsAtTimestamp.forEach(evt => {
        if (evt && evt.event && evt.tx && evt.event.name) {
          // Check if this event is already in the trade's events
          const isDuplicate = activeTrade.events.some(existingEvt => 
            existingEvt?.tx.signature === evt.tx?.signature && 
            existingEvt?.event?.name === evt.event?.name
          );
          
          if (!isDuplicate) {
            activeTrade.events.push(evt);
          }
        }
      });
      
      // Update the trade with liquidation data
      activeTrade.status = "liquidated";
      activeTrade.exitPrice = price;
      activeTrade.closeTime = tx.blockTime;
      
      // Use Jupiter's hasProfit field with the absolute pnlDelta value for liquidation
      const actualPnlDelta = calculateActualPnl(
        data.hasProfit,
        pnlDelta
      );
      
      activeTrade.pnl = (activeTrade.pnl || 0) + actualPnlDelta;
      activeTrade.hasProfit = (activeTrade.pnl || 0) > 0;
      activeTrade.totalFees = (activeTrade.totalFees || 0) + fee + liquidationFee;  // Add liquidation fee to total
      
      // Store the maximum size the position reached
      activeTrade.finalSize = activeTrade.maxSize || activeTrade.sizeUsd;
      activeTrade.sizeUsd = 0; // Set size to 0 as it's fully liquidated
      
      // Calculate ROI based on PnL and collateral
      if (activeTrade.pnl !== undefined) {
        activeTrade.roi = (activeTrade.pnl / activeTrade.collateralUsd) * 100;
      }
      
      // Move to completed trades
      completedTrades.push({ ...activeTrade });
      activeTrades.delete(positionKey);
    }
    // Handle TP/SL events
    else if (name === 'InstantCreateTpslEvent' || name === 'InstantUpdateTpslEvent') {
      // For TP/SL events, we need to find the active trade for this position
      if (!activeTrade) {

        continue;
      }

      // Add all events from this timestamp
      allEventsAtTimestamp.forEach(evt => {
        if (evt && evt.event && evt.tx && evt.event.name) {
          // Check if this event is already in the trade's events
          const isDuplicate = activeTrade.events.some(existingEvt => 
            existingEvt?.tx.signature === evt.tx?.signature && 
            existingEvt?.event?.name === evt.event?.name
          );
          
          if (!isDuplicate) {
            activeTrade.events.push(evt);
          }
        }
      });
    }
  }

  // Sort events chronologically within each trade
  const sortTradeEvents = (trade: ITrade) => {
    trade.events.sort((a, b) => {
      const aTime = a?.tx.blockTime ? new Date(a.tx.blockTime).getTime() : 0;
      const bTime = b?.tx.blockTime ? new Date(b.tx.blockTime).getTime() : 0;
      
      // If timestamps are the same, use event type to determine order
      if (aTime === bTime) {
        // Prioritize decrease position events over pool swap events
        if (a?.event?.name === 'DecreasePositionEvent' && b?.event?.name === 'PoolSwapEvent') {
          return -1; // a comes before b
        }
        if (a?.event?.name === 'PoolSwapEvent' && b?.event?.name === 'DecreasePositionEvent') {
          return 1; // b comes before a
        }
        
        // Same logic for instant decrease position events
        if (a?.event?.name === 'InstantDecreasePositionEvent' && b?.event?.name === 'PoolSwapEvent') {
          return -1;
        }
        if (a?.event?.name === 'PoolSwapEvent' && b?.event?.name === 'InstantDecreasePositionEvent') {
          return 1;
        }
      }
      
      // Default to sorting by timestamp
      return aTime - bTime;
    });
    return trade;
  };

  // Function to calculate weighted average entry and exit prices
  const calculateWeightedAverages = (trade: ITrade) => {
    let totalEntryValue = 0;
    let totalEntrySize = 0;
    let totalExitValue = 0;
    let totalExitSize = 0;

    // Process all events to calculate weighted averages
    trade.events.forEach(evt => {
      if (!evt?.event) return;
      
      const eventName = evt.event.name;
      const eventData = evt.event.data;
      
      // Handle increase events for weighted average entry price
      if (eventName === 'IncreasePositionEvent' || eventName === 'InstantIncreasePositionEvent') {
        const sizeUsdDelta = parseUsdValue(eventData.sizeUsdDelta || '0');
        const price = parseUsdValue(eventData.price || '0');
        
        if (sizeUsdDelta > 0 && price > 0) {
          totalEntryValue += sizeUsdDelta * price;
          totalEntrySize += sizeUsdDelta;
        }
      }
      
      // Handle decrease events for weighted average exit price
      if (eventName === 'DecreasePositionEvent' || eventName === 'InstantDecreasePositionEvent') {
        const sizeUsdDelta = parseUsdValue(eventData.sizeUsdDelta || '0');
        const price = parseUsdValue(eventData.price || '0');
        
        if (sizeUsdDelta > 0 && price > 0) {
          totalExitValue += sizeUsdDelta * price;
          totalExitSize += sizeUsdDelta;
        }
      }
      
      // Handle liquidation events for weighted average exit price
      if (eventName === 'LiquidateFullPositionEvent') {
        const positionSizeUsd = parseUsdValue(eventData.positionSizeUsd || '0');
        const price = parseUsdValue(eventData.price || '0');
        
        if (positionSizeUsd > 0 && price > 0) {
          totalExitValue += positionSizeUsd * price;
          totalExitSize += positionSizeUsd;
        }
      }
    });

    // Calculate and update weighted average entry price
    if (totalEntrySize > 0) {
      trade.entryPrice = totalEntryValue / totalEntrySize;
    }

    // Calculate and update weighted average exit price
    if (totalExitSize > 0) {
      trade.exitPrice = totalExitValue / totalExitSize;
    }

    return trade;
  };

  // Convert maps to arrays for return
  const activeTradesArray = Array.from(activeTrades.values()).map(trade => calculateWeightedAverages(sortTradeEvents(trade)));
  
  // Sort completed trades by recency (newest first)
  completedTrades.sort((a, b) => {
    const aTime = a.closeTime ? new Date(a.closeTime).getTime() : 0;
    const bTime = b.closeTime ? new Date(b.closeTime).getTime() : 0;
    return bTime - aTime;
  });
  
  return {
    activeTrades: activeTradesArray,
    completedTrades: completedTrades.map(trade => calculateWeightedAverages(sortTradeEvents(trade))),
  };
}

// Enhance formatting for TP/SL instruction data when extracted from event
function formatTpslInstructionData(data: any): string {
  if (!data || !data.params) return "Not available";
  
  let output = [];
  
  if (data.params.takeProfitTriggerPrice) {
    const tpPrice = BNToUSDRepresentation(data.params.takeProfitTriggerPrice, USDC_DECIMALS);
    output.push(`Take Profit: $${tpPrice} (${data.params.takeProfitSizePct / 100}%)`);
  }
  
  if (data.params.stopLossTriggerPrice) {
    const slPrice = BNToUSDRepresentation(data.params.stopLossTriggerPrice, USDC_DECIMALS);
    output.push(`Stop Loss: $${slPrice} (${data.params.stopLossSizePct / 100}%)`);
  }
  
  return output.join(", ");
}

// Helper function to find the original create event for an update event
function findOriginalCreateTpslEvent(events: EventWithTx[], updateEvent: any): any | null {
  const updateRequestKey = updateEvent.event.data.positionRequestKey;
  if (!updateRequestKey) return null;
  
  // Find the most recent create event with the same positionRequestKey
  for (let i = events.length - 1; i >= 0; i--) {
    const event = events[i];
    if (event?.event?.name === 'InstantCreateTpslEvent' && 
        event.event.data.positionRequestKey === updateRequestKey &&
        event.event.data.tpslInstructionData) {
      return event.event.data.tpslInstructionData;
    }
  }
  return null;
}

/**
 * Get the complete trade history for all position PDAs of a wallet with optional date filtering
 */
export async function getPositionTradeHistory(fromDateString?: string, walletAddress?: string, toDateString?: string): Promise<{ activeTrades: ITrade[]; completedTrades: ITrade[] }> {
  // Get all events for the wallet's position PDAs with date filtering
  const events = await getPositionEvents(fromDateString, walletAddress, toDateString);
  
  // Commented out raw events display for clean JSON output

  // ... (raw events logging code removed for clean JSON output) ...
  
  // Group events into trades
  return groupEventsIntoTrades(events);
}

/**
 * PARALLEL VERSION - Get the complete trade history using parallel processing for faster execution
 * This version can be 2-3x faster than the sequential version
 */
export async function getPositionTradeHistoryParallel(fromDateString?: string, walletAddress?: string, toDateString?: string): Promise<{ activeTrades: ITrade[]; completedTrades: ITrade[] }> {
  if (!walletAddress) {
    throw new Error("Wallet address is required");
  }
  // Get all events for the wallet's position PDAs with date filtering using parallel processing
  const events = await getPositionEventsParallel(fromDateString, walletAddress, toDateString);
  
  // Group events into trades (same logic as sequential version)
  return groupEventsIntoTrades(events);
}

// Helper function to format limit order data
function formatLimitOrderData(data: any): string {
  if (!data || !data.params) return "Not available";
  
  let output = [];
  
  if (data.params.price) {
    const price = BNToUSDRepresentation(data.params.price, USDC_DECIMALS);
    output.push(`Limit Price: $${price}`);
  }
  
  if (data.params.size) {
    const size = BNToUSDRepresentation(data.params.size, USDC_DECIMALS);
    output.push(`Size: $${size}`);
  }
  
  // Add more fields as needed
  
  return output.join(", ");
}

/**
 * Example usage with date support and wallet address - JSON output version
 */
export async function analyzeTradeHistoryJson(fromDateString?: string, walletAddress?: string, toDateString?: string): Promise<JsonOutput> {
  if (!walletAddress) {
    throw new Error("Wallet address is required");
  }
  const wallet = walletAddress;
  // Use parallel version for faster execution
  const { activeTrades, completedTrades } = await getPositionTradeHistoryParallel(fromDateString, walletAddress, toDateString);
  // Transform to JSON format
  const jsonOutput = transformTradesToJson(activeTrades, completedTrades, wallet);
  return jsonOutput;
}

/**
 * Legacy function for console output (kept for backward compatibility)
 */
async function analyzeTradeHistory(fromDateString?: string, walletAddress?: string, toDateString?: string) {
  const { activeTrades, completedTrades } = await getPositionTradeHistory(fromDateString, walletAddress, toDateString);
  

  
  // Print detailed trade information
  if (activeTrades.length > 0) {

    for (let i = 0; i < activeTrades.length; i++) {
      await printDetailedTradeInfo(activeTrades[i], i);
    }
  }
  
  if (completedTrades.length > 0) {

    for (let i = 0; i < completedTrades.length; i++) {
      await printDetailedTradeInfo(completedTrades[i], i);
    }
  }

}

// Update the printDetailedTradeInfo function to better display TP/SL data and add limit order info
async function printDetailedTradeInfo(trade: ITrade, index: number) {
  const side = trade.positionSide;
  const status = trade.status === "liquidated" ? "LIQUIDATED" : (trade.status === "closed" ? "CLOSED" : "ACTIVE");
  const pnl = trade.pnl ? `$${trade.pnl.toFixed(2)}` : "N/A";
  const roi = trade.roi ? `${trade.roi.toFixed(2)}%` : "N/A";
  

  // Debug - Check if InstantCreateTpslEvent is in the events array
  
  // Replace Position field with Symbol

  
  // Show just Long or Short as Direction

  


  
  if (trade.exitPrice) {

  }
  
  // Show finalSize for completed trades if available, otherwise show sizeUsd
  const displaySize = (trade.status !== "active" && trade.finalSize) ? 
    trade.finalSize : trade.sizeUsd;
  
  // Show max size if it's different from current size (indicating multiple increases)
  if (trade.maxSize && trade.maxSize !== displaySize) {

  }
  
  // Calculate and display notional size using the display size (current/final size)
  if (trade.entryPrice > 0) {
    const notionalSize = displaySize / trade.entryPrice;
  }
  


  
  // Display total fees

  

  
  // Add token information for the position
  const firstEvent = trade.events.find(evt => 
    evt?.event?.name === 'IncreasePositionEvent' || 
    evt?.event?.name === 'InstantIncreasePositionEvent'
  );
  
  if (firstEvent?.event?.data) {
    const collateralCustody = firstEvent.event.data.positionCollateralCustody;
  }
  
  // Check for swaps in the trade
  const hasOpeningSwap = trade.events.some(evt => evt?.event?.name === 'IncreasePositionPreSwapEvent');
  const hasClosingSwap = trade.events.some(evt => evt?.event?.name === 'DecreasePositionPostSwapEvent');
  
  // Add token comparison detection for swaps
  const firstIncreaseEvent = trade.events.find(evt => 
    evt?.event?.name === 'IncreasePositionEvent' || 
    evt?.event?.name === 'InstantIncreasePositionEvent'
  );

  const lastDecreaseEvent = trade.events.find(evt => 
    (evt?.event?.name === 'DecreasePositionEvent' || 
    evt?.event?.name === 'InstantDecreasePositionEvent' ||
    evt?.event?.name === 'LiquidateFullPositionEvent') &&
    (trade.status !== "active")
  );

  let swapDetectedByTokens = false;
  let openingSwapByTokens = false;
  let closingSwapByTokens = false;

  // Check for opening swap by comparing tokens
  if (firstIncreaseEvent?.event?.data) {
    const data = firstIncreaseEvent.event.data;
    const collateralCustody = data.positionCollateralCustody;
    const requestMint = data.positionRequestMint;
    
    // Only compare if both values are defined
    if (collateralCustody && requestMint) {
      // For longs: if input token differs from collateral token
      // For shorts: if input token is not USDC/USDT
      if (data.positionSide === "Long") {
        // For longs, the collateral token and request mint should be the same if no swap
        openingSwapByTokens = getAssetNameFromCustody(collateralCustody) !== getSymbolFromMint(requestMint);
      } else {
        // For shorts, the request mint should be USDC or USDT if no swap
        const requestSymbol = getSymbolFromMint(requestMint);
        openingSwapByTokens = requestSymbol !== "USDC" && requestSymbol !== "USDT";
      }
    }
  }

  // Check for closing swap by comparing tokens
  if (lastDecreaseEvent?.event?.data) {
    const data = lastDecreaseEvent.event.data;
    const collateralCustody = data.positionCollateralCustody;
    const requestMint = data.positionRequestMint;
    
    if (collateralCustody && requestMint) {
      // If collateral custody differs from request mint, a swap occurred
      closingSwapByTokens = getAssetNameFromCustody(collateralCustody) !== getSymbolFromMint(requestMint);
    }
  }

  swapDetectedByTokens = openingSwapByTokens || closingSwapByTokens;

  // Combine both detection methods
  const swapsDetected = hasOpeningSwap || hasClosingSwap || swapDetectedByTokens;
  const openingSwaps = hasOpeningSwap || openingSwapByTokens;
  const closingSwaps = hasClosingSwap || closingSwapByTokens;


  
  // Add payout information for closed/liquidated positions
  if (trade.status !== "active") {
    const lastEvent = trade.events.find(evt => 
      evt?.event?.name === 'DecreasePositionEvent' || 
      evt?.event?.name === 'InstantDecreasePositionEvent' ||
      evt?.event?.name === 'LiquidateFullPositionEvent'
    );
    
    if (lastEvent?.event?.data) {
      const data = lastEvent.event.data;
      

      
      if (data.transferToken) {
        const tokenAmount = Number(data.transferToken);
        const requestMint = data.positionRequestMint || data.desiredMint;
        let tokenSymbol = "Unknown";
        let decimals = 6; // Default to 6 decimals (USDC)
        
        // Try to determine token symbol and decimals
        if (requestMint) {
          // Known token addresses
          if (requestMint === "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v") {
            tokenSymbol = "USDC";
            decimals = 6;
          } else if (requestMint === "So11111111111111111111111111111111111111112") {
            tokenSymbol = "SOL";
            decimals = 9;
          } else if (requestMint === "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs") {
            tokenSymbol = "WETH";
            decimals = 8;
          }
        }
        
        const formattedAmount = (tokenAmount / Math.pow(10, decimals)).toFixed(decimals === 9 ? 6 : 2);
        
        // If we have both USD and token amounts, calculate implied swap fee
        if (data.transferAmountUsd && parseUsdValue(data.transferAmountUsd) > 0) {
          const usdAmount = parseUsdValue(data.transferAmountUsd);
          const tokenInUsd = tokenAmount / Math.pow(10, decimals);
          
          // If there's a significant difference, it might indicate swap fees
          if (Math.abs(usdAmount - tokenInUsd) > 0.1 && tokenSymbol === "USDC") {
            const impliedFee = usdAmount - tokenInUsd;
          }
        }
      }
    }
  }
  

  

  
  // Check for TP/SL events in the trade
  const hasTpslEvent = trade.events.some(evt => 
    evt?.event?.name === 'InstantCreateTpslEvent' || 
    evt?.event?.name === 'InstantUpdateTpslEvent'
  );

  if (hasTpslEvent) {
    // Find the most recent TP/SL event to show current values
    const tpslEvent = [...trade.events]
      .reverse()
      .find(evt => 
        evt?.event?.name === 'InstantCreateTpslEvent' || 
        evt?.event?.name === 'InstantUpdateTpslEvent'
      );
    
    if (tpslEvent?.event?.data) {
      const data = tpslEvent.event.data;
      
      // First check if we have instruction data directly in the event
      if (data.tpslInstructionData && data.tpslInstructionData.params) {
        const tpslData = data.tpslInstructionData;
        
        // For UPDATE events, retrieve triggerAboveThreshold from original CREATE event
        let actualTriggerAboveThreshold = data.tpslTriggerAboveThreshold;
        if (tpslData.instructionName === 'instantUpdateTpsl') {
          const originalCreateData = findOriginalCreateTpslEvent(trade.events, tpslEvent);
          if (originalCreateData && originalCreateData.params) {
            actualTriggerAboveThreshold = originalCreateData.params.triggerAboveThreshold;
          }
        }
        
        const isTP = actualTriggerAboveThreshold;
        const isSL = !actualTriggerAboveThreshold;
        
        // For update events, try to find the original create event to get correct values
        let actualEntirePosition = data.tpslEntirePosition;
        let actualSizePercentage = calculateTpslSizePercentage(
          actualEntirePosition,
          data.tpslSizeUsdDelta || '$0.00',
          trade.sizeUsd
        );
        
        if (tpslData.instructionName === 'instantUpdateTpsl') {
          const originalCreateData = findOriginalCreateTpslEvent(trade.events, tpslEvent);
          if (originalCreateData && originalCreateData.params) {
            actualEntirePosition = originalCreateData.params.entirePosition;
            // For UPDATE events, we need to get the size from the original CREATE event
            const originalSizeUsdDelta = originalCreateData.data?.tpslSizeUsdDelta || '$0.00';
            actualSizePercentage = calculateTpslSizePercentage(
              actualEntirePosition,
              originalSizeUsdDelta,
              trade.sizeUsd
            );
          }
        } else if (tpslData.instructionName === 'instantCreateTpsl') {
          // For create events, use the values directly from the event
          actualSizePercentage = calculateTpslSizePercentage(
            actualEntirePosition,
            data.tpslSizeUsdDelta || '$0.00',
            trade.sizeUsd
          );
        }
        

      }
    }
  }
  
  // Check for limit order events in the trade
  const hasLimitOrderEvent = trade.events.some(evt => 
    evt?.event?.name === 'InstantCreateLimitOrderEvent' || 
    evt?.event?.name === 'InstantUpdateLimitOrderEvent' ||
    evt?.event?.name === 'FillLimitOrderEvent'
  );

  if (hasLimitOrderEvent) {
    // Find the most recent limit order event to show current values
    const limitOrderEvent = [...trade.events]
      .reverse()
      .find(evt => 
        evt?.event?.name === 'InstantCreateLimitOrderEvent' || 
        evt?.event?.name === 'InstantUpdateLimitOrderEvent' ||
        evt?.event?.name === 'FillLimitOrderEvent'
      );
    
    if (limitOrderEvent?.event?.data) {
      const data = limitOrderEvent.event.data;
      
      // First check if we have instruction data directly in the event
      if (data.limitOrderInstructionData && data.limitOrderInstructionData.params) {
        const orderData = data.limitOrderInstructionData;
        

      } else if (limitOrderEvent.event.name === 'FillLimitOrderEvent') {
        // For fill events, we can display information directly from the event
      } else {
      }
    } else {
    }
  }
  

  

  trade.events.forEach((evt, i) => {
    if (evt && evt.event) {
      const eventData = evt.event.data;
      const eventType = evt.event.name;
      const eventTime = evt.tx.blockTime || "Unknown";
      
      // Special handling for PoolSwapEvent in trade events
      if (eventType === 'PoolSwapEvent' || eventType === 'PoolSwapExactOutEvent') {
        // Get tokens by custody addresses
        const receivingCustody = eventData.receivingCustodyKey || 'Unknown';
        const dispensingCustody = eventData.dispensingCustodyKey || 'Unknown';
        
        const receivingSymbol = getAssetNameFromCustody(receivingCustody);
        const dispensingSymbol = getAssetNameFromCustody(dispensingCustody);
        
        // Format amounts with appropriate decimals - match amountIn with receivingCustody (token going in)
        if (eventData.amountIn) {
          const amountIn = Number(eventData.amountIn);
          const formattedAmount = formatTokenAmount(amountIn, receivingSymbol);
        }
        
        // Match amountOut with dispensingCustody (token coming out)
        if (eventData.amountOut) {
          const amountOut = Number(eventData.amountOut);
          const formattedAmount = formatTokenAmount(amountOut, dispensingSymbol);
        }
        
        // Show amount out after fees
        if (eventData.amountOutAfterFees) {
          const amountOutAfterFees = Number(eventData.amountOutAfterFees);
          const formattedAmount = formatTokenAmount(amountOutAfterFees, dispensingSymbol);
        }
        
        if (eventData.feeBps) {
          const feeBpsNum = Number(eventData.feeBps);
          
          // Calculate actual fee amount if available
          if (eventData.amountOutAfterFees && eventData.amountOut) {
            const feeAmount = Number(eventData.amountOut) - Number(eventData.amountOutAfterFees);
            const formattedFee = formatTokenAmount(feeAmount, dispensingSymbol);
          }
        }
      }
      // Special handling for TP/SL events
      else if (eventType === 'InstantCreateTpslEvent' || eventType === 'InstantUpdateTpslEvent') {
        // For UPDATE events, retrieve triggerAboveThreshold from original CREATE event
        let actualTriggerAboveThreshold = eventData.tpslTriggerAboveThreshold;
        if (eventType === 'InstantUpdateTpslEvent') {
          const originalCreateData = findOriginalCreateTpslEvent(trade.events, evt);
          if (originalCreateData && originalCreateData.params) {
            actualTriggerAboveThreshold = originalCreateData.params.triggerAboveThreshold;
          }
        }
        
        // Determine if Take Profit or Stop Loss
        const isTakeProfit = actualTriggerAboveThreshold === true;
        const orderType = isTakeProfit ? "Take Profit" : "Stop Loss";
        
        // For update events, try to find the original create event to get correct values
        let actualEntirePosition = eventData.tpslEntirePosition;
        let actualSizePercentage = calculateTpslSizePercentage(
          actualEntirePosition,
          eventData.tpslSizeUsdDelta || '$0.00',
          trade.sizeUsd
        );
        
        if (eventType === 'InstantUpdateTpslEvent') {
          const originalCreateData = findOriginalCreateTpslEvent(trade.events, evt);
          if (originalCreateData && originalCreateData.params) {
            actualEntirePosition = originalCreateData.params.entirePosition;
            // For UPDATE events, we need to get the size from the original CREATE event
            const originalSizeUsdDelta = originalCreateData.data?.tpslSizeUsdDelta || '$0.00';
            actualSizePercentage = calculateTpslSizePercentage(
              actualEntirePosition,
              originalSizeUsdDelta,
              trade.sizeUsd
            );
          }
        } else if (eventType === 'InstantCreateTpslEvent') {
          // For create events, use the values directly from the event
          actualSizePercentage = calculateTpslSizePercentage(
            actualEntirePosition,
            eventData.tpslSizeUsdDelta || '$0.00',
            trade.sizeUsd
          );
        }
        
      }
      // For regular events (not pool swap or TP/SL)
      else {
        // Determine if buy or sell
        let action = "Buy"; // Default to Buy to avoid empty strings
        if (eventType.includes('Increase') || eventType.includes('PreSwap')) {
          action = trade.positionSide === "Long" ? "Buy" : "Sell";
        } else if (eventType.includes('Decrease') || eventType.includes('Liquidate') || eventType.includes('PostSwap')) {
          action = trade.positionSide === "Long" ? "Sell" : "Buy";
        } else if (eventType.includes('FillLimitOrder')) {
          // For limit orders, determine based on the trade direction
          action = trade.positionSide === "Long" ? "Buy" : "Sell";
        } else if (eventType.includes('Tpsl') || eventType.includes('TPSL')) {
          // For TP/SL events, they are typically closing events
          action = trade.positionSide === "Long" ? "Sell" : "Buy";
        }
        
        // Determine if market or limit based on positionRequestType and event name
        let orderType = "Market"; // Default to Market
        if (eventType.includes('Instant')) {
          // All Instant events are market orders by definition
          orderType = "Market";
        } else if (eventType.includes('FillLimitOrder')) {
          orderType = "Limit";
        } else if (eventType.includes('Liquidate')) {
          // Liquidations are always forced liquidation orders
          orderType = "Liquidation";
        } else if (eventType.includes('Tpsl') || eventType.includes('TPSL')) {
          // TP/SL events - simplified approach
          orderType = "Take Profit";
        } else if (eventType.includes('Increase') || eventType.includes('Decrease')) {
          // For non-Instant events, check positionRequestType if available
          if (eventData.positionRequestType !== undefined) {
            orderType = eventData.positionRequestType === 0 ? "Market" : "Limit";
          }
        }
        

        
        // Display token information
        if (eventData.positionMint) {
          const symbol = getSymbolFromMint(eventData.positionMint);
        }
        
        if (eventData.positionRequestMint) {
          const symbol = getSymbolFromMint(eventData.positionRequestMint);
        }
        
        // Get sizes - with special handling for liquidation events
        let sizeUsd = 0;
        if (eventType.includes('Liquidate')) {
          // For liquidation events, use positionSizeUsd instead of sizeUsdDelta
          sizeUsd = parseUsdValue(eventData.positionSizeUsd || "0");
        } else {
          sizeUsd = parseUsdValue(eventData.sizeUsdDelta || "0");
        }
        
        const price = parseUsdValue(eventData.price || "0");
        const notionalSize = price > 0 ? sizeUsd / price : 0;
        

        
        // Add payout information for decrease/liquidation events
        if (eventType.includes('Decrease') || eventType.includes('Liquidate')) {

          
          if (eventData.transferToken) {
            const tokenAmount = Number(eventData.transferToken);
            const requestMint = eventData.positionRequestMint || eventData.desiredMint;
            let tokenSymbol = "Unknown";
            let decimals = 6; // Default to 6 decimals (USDC)
            
            // Try to determine token symbol and decimals
            if (requestMint) {
              // Known token addresses
              if (requestMint === "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v") {
                tokenSymbol = "USDC";
                decimals = 6;
              } else if (requestMint === "So11111111111111111111111111111111111111112") {
                tokenSymbol = "SOL";
                decimals = 9;
              } else if (requestMint === "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs") {
                tokenSymbol = "WETH";
                decimals = 8;
              }
            }
            
            const formattedAmount = (tokenAmount / Math.pow(10, decimals)).toFixed(decimals === 9 ? 6 : 2);
          }
        }
        
        // Handle fees display - with special handling for liquidation events
        const fee = parseUsdValue(eventData.feeUsd || "0");
        
        if (eventType.includes('Liquidate') && eventData.liquidationFeeUsd) {
          const liquidationFee = parseUsdValue(eventData.liquidationFeeUsd);
        }
        
        // Add collateral information for relevant events - simplified
        if (eventType.includes('Increase') || eventType.includes('Decrease')) {
          const collateralUsd = parseUsdValue(eventData.collateralUsdDelta || "0");
        }
        
        // Show profit/loss information for decrease events
        if ((eventType.includes('Decrease') || eventType.includes('Liquidate')) && eventData.pnlDelta) {
          const pnlDelta = parseUsdValue(eventData.pnlDelta);
        }
      }
    }
  });
}

// Helper function to get token symbol from mint address
function getSymbolFromMint(mintAddress: string | undefined): string {
  // Check if mintAddress is undefined or null
  if (!mintAddress) {
    return "Unknown";
  }
  
  // Common token addresses
  switch(mintAddress) {
    case "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v":
      return "USDC";
    case "So11111111111111111111111111111111111111112":
      return "SOL";
    case "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs":
      return "WETH";
    case "3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh":
      return "wBTC";
    default:
      return mintAddress.substring(0, 6) + "...";
  }
}

// Helper function to format token amounts with appropriate decimals
function formatTokenAmount(amount: number, tokenSymbol: string): string {
  // Get decimals based on token
  let decimals = 6; // Default (USDC, USDT)
  
  switch(tokenSymbol) {
    case "SOL":
      decimals = 9;
      break;
    case "ETH":
    case "WETH":
      decimals = 8;
      break;
    case "BTC":
    case "wBTC":
      decimals = 8;
      break;
    case "USDC":
    case "USDT":
      decimals = 6;
      break;
  }
  
  // Format the amount
  const formattedAmount = (amount / Math.pow(10, decimals)).toFixed(decimals === 9 ? 3 : 2);
  return formattedAmount;
}

// Add helper function to get asset name from custody pubkey if not already present
function getAssetNameFromCustody(custodyPubkey: string | undefined): string {
  if (!custodyPubkey) {
    return "Unknown";
  }
  
  switch(custodyPubkey) {
    case CUSTODY_PUBKEY.SOL:
      return "SOL";
    case CUSTODY_PUBKEY.ETH:
      return "ETH";
    case CUSTODY_PUBKEY.BTC:
      return "BTC";
    case CUSTODY_PUBKEY.USDC:
      return "USDC";
    case CUSTODY_PUBKEY.USDT:
      return "USDT";
    default:
      // Return a shortened version of the pubkey for unknown custody addresses
      return `${custodyPubkey.substring(0, 6)}...`;
  }
}

/**
 * Jupiter Perpetuals Trade History Analyzer with Date Range Support and Multi-PDA Analysis
 * 
 * To analyze trades across all position PDAs for a wallet within a specific date range:
 * 1. Update the FROM_DATE variable with your desired start date (older date, where analysis begins) in DD.MM.YYYY format
 * 2. Update the TO_DATE variable with your desired end date (newer date, where analysis ends) in DD.MM.YYYY format
 * 3. Set TO_DATE to undefined to end at "now" (current moment)
 * 4. Set FROM_DATE to undefined to use default (30 days ago from TO_DATE)
 * 5. Update the WALLET_ADDRESS to analyze a different wallet's trades
 * 
 * Examples:
 * - FROM_DATE = "13.04.2025", TO_DATE = "15.04.2025" - Analyze transactions from April 13th to April 15th, 2025
 * - FROM_DATE = "01.04.2025", TO_DATE = undefined - Analyze from April 1st to now
 * - FROM_DATE = undefined, TO_DATE = undefined - Analyze transactions from the last 30 days (default)
 * 
 * Note: FROM_DATE must be older (earlier) than TO_DATE for a valid chronological range
 */

// ============================
// const FROM_DATE = "01.01.2025"; // Start date - where to begin analysis (older date)
// const TO_DATE = "08.07.2025"; // End date - where to finish analysis (newer date), set to undefined for "now"
// const WALLET_ADDRESS = "CCzT1sYFhUMftUYXciKWwjSNVfsPetygMpmRRHpXNRYR"; // Wallet to analyze
// ============================



// Helper function to calculate TP/SL size percentage
function calculateTpslSizePercentage(
  entirePosition: boolean,
  sizeUsdDelta: string,
  positionSizeUsd: number
): string {
  if (entirePosition) {
    return "100%";
  }
  
  // For partial positions, calculate actual percentage
  const deltaUsd = parseUsdValue(sizeUsdDelta);
  if (deltaUsd > 0 && positionSizeUsd > 0) {
    const percentage = (deltaUsd / positionSizeUsd) * 100;
    return `${percentage.toFixed(1)}%`;
  }
  
  // Fallback if we can't calculate
  return "Partial position";
}

// Add new interfaces for JSON output format
interface JsonEvent {
  timestamp: string;
  transaction_signature: string;
  event_name: string;
  action: string;
  type: string;
  size_usd: number;
  price: number;
  fee_usd: number;
  pnl_usd?: number;
  has_profit?: boolean;
}

interface JsonPosition {
  trade_id: string;
  position_key: string;
  symbol: string;
  direction: string;
  status: string;
  collateral_token: string;
  size_usd: number;
  notional_size: number;
  collateral_usd: number;
  leverage: number;
  entry_price: number;
  exit_price?: number;
  realized_pnl?: number;
  realized_pnl_percent?: number;
  total_fees: number;
  has_profit?: boolean;
  entry_time: string;
  exit_time?: string;
  events: JsonEvent[];
}

interface JsonOutput {
  wallet_address: string;
  sync_timestamp: string;
  positions: JsonPosition[];
}

// Function to transform trades to JSON format
function transformTradesToJson(
  activeTrades: ITrade[], 
  completedTrades: ITrade[], 
  walletAddress: string
): JsonOutput {
  const allTrades = [...completedTrades, ...activeTrades];
  
  const positions: JsonPosition[] = allTrades.map(trade => {
    // Transform events to simplified JSON format
    const jsonEvents: JsonEvent[] = trade.events
      .filter(evt => evt?.event && evt?.tx)
      .map(evt => {
        const eventData = evt!.event!.data;
        const eventName = evt!.event!.name;
        
        // Determine action based on event type
        let action = "Buy"; // Default to Buy to avoid constraint violations
        if (eventName.includes('Increase') || eventName.includes('PreSwap')) {
          action = trade.positionSide === "Long" ? "Buy" : "Sell";
        } else if (eventName.includes('Decrease') || eventName.includes('Liquidate') || eventName.includes('PostSwap')) {
          action = trade.positionSide === "Long" ? "Sell" : "Buy";
        } else if (eventName.includes('FillLimitOrder')) {
          // For limit orders, determine based on the trade direction
          action = trade.positionSide === "Long" ? "Buy" : "Sell";
        } else if (eventName.includes('Tpsl') || eventName.includes('TPSL')) {
          // For TP/SL events, they are typically closing events
          action = trade.positionSide === "Long" ? "Sell" : "Buy";
        }
        
        // Determine type (Market vs Limit)
        let type = "Market"; // Default to Market
        if (eventName.includes('Instant')) {
          type = "Market";
        } else if (eventName.includes('FillLimitOrder')) {
          type = "Limit";
        } else if (eventName.includes('Liquidate')) {
          type = "Liquidation";
        } else if (eventName.includes('Tpsl') || eventName.includes('TPSL')) {
          // Determine if it's Take Profit or Stop Loss based on trigger direction
          // This is a simplified approach - could be enhanced with more context
          type = "Take Profit"; // Default for TP/SL events
        } else if (eventData.positionRequestType !== undefined) {
          type = eventData.positionRequestType === 0 ? "Market" : "Limit";
        }
        
        // Get size USD - handle liquidation events differently
        let sizeUsd = 0;
        if (eventName.includes('Liquidate')) {
          sizeUsd = parseUsdValue(eventData.positionSizeUsd || "0");
        } else {
          sizeUsd = parseUsdValue(eventData.sizeUsdDelta || "0");
        }
        
        // Get price and fee
        const price = parseUsdValue(eventData.price || "0");
        const feeUsd = parseUsdValue(eventData.feeUsd || "0");
        
        // Get PnL data for events that have it (decrease and liquidation events)
        let pnlUsd: number | undefined;
        let hasProfit: boolean | undefined;
        
        if (eventName.includes('Decrease') || eventName.includes('Liquidate')) {
          // Jupiter provides PnL data in multiple possible fields
          if (eventData.pnlUsd) {
            pnlUsd = parseUsdValue(eventData.pnlUsd);
            hasProfit = eventData.hasProfit !== undefined ? eventData.hasProfit : (pnlUsd > 0);
          } else if (eventData.pnlDelta) {
            pnlUsd = parseUsdValue(eventData.pnlDelta);
            hasProfit = eventData.hasProfit !== undefined ? eventData.hasProfit : (pnlUsd > 0);
          } else if (eventData.realizedPnl) {
            pnlUsd = parseUsdValue(eventData.realizedPnl);
            hasProfit = eventData.hasProfit !== undefined ? eventData.hasProfit : (pnlUsd > 0);
          }
        }
        
        return {
          timestamp: evt!.tx.blockTime || new Date().toISOString(),
          transaction_signature: evt!.tx.signature,
          event_name: eventName,
          action,
          type,
          size_usd: Math.round(sizeUsd * 100) / 100, // Round to 2 decimal places
          price: Math.round(price * 100) / 100, // Round to 2 decimal places
          fee_usd: Math.round(feeUsd * 100) / 100, // Round to 2 decimal places
          ...(pnlUsd !== undefined && { pnl_usd: Math.round(pnlUsd * 100) / 100 }),
          ...(hasProfit !== undefined && { has_profit: hasProfit })
        };
      });
    
    // Get collateral token from the first event
    let collateralToken = "Unknown";
    const firstEvent = trade.events.find(evt => 
      evt?.event?.name === 'IncreasePositionEvent' || 
      evt?.event?.name === 'InstantIncreasePositionEvent'
    );
    
    if (firstEvent?.event?.data?.positionCollateralCustody) {
      collateralToken = getAssetNameFromCustody(firstEvent.event.data.positionCollateralCustody);
    }
    
    // Format symbol as ASSET-PERP
    const symbol = trade.asset ? `${trade.asset}-PERP` : "UNKNOWN-PERP";
    
    // Use finalSize for completed trades, sizeUsd for active trades
    const displaySize = (trade.status !== "active" && trade.finalSize) ?
      trade.finalSize : trade.sizeUsd;
    
    // Calculate notional size (actual token amount) = position size USD / entry price
    const notionalSize = trade.entryPrice > 0 ? displaySize / trade.entryPrice : 0;
    
    // Build the position object with proper field ordering to match the desired structure
    const position: JsonPosition = {
      trade_id: trade.id,
      position_key: trade.positionKey,
      symbol,
      direction: trade.positionSide.toLowerCase(),
      status: trade.status,
      collateral_token: collateralToken,
      size_usd: Math.round(displaySize * 100) / 100, // Round to 2 decimal places
      notional_size: Math.round(notionalSize * 100) / 100, // Round to 2 decimal places for consistency
      collateral_usd: Math.round(trade.collateralUsd * 100) / 100, // Round to 2 decimal places
      leverage: Math.round(trade.leverage * 100) / 100, // Round to 2 decimal places
      entry_price: Math.round(trade.entryPrice * 100) / 100,
      // Add exit_price right after entry_price for completed trades
      ...(trade.status !== "active" && trade.exitPrice && {
        exit_price: Math.round(trade.exitPrice * 100) / 100
      }),
      // Add realized_pnl after exit_price for completed trades
      ...(trade.status !== "active" && trade.pnl !== undefined && {
        realized_pnl: Math.round(trade.pnl * 100) / 100,
        realized_pnl_percent: trade.collateralUsd > 0 ? Math.round((trade.pnl / trade.collateralUsd) * 100 * 100) / 100 : 0
      }),
      total_fees: Math.round((trade.totalFees || 0) * 100) / 100,
      // Add has_profit for completed trades
      ...(trade.status !== "active" && trade.hasProfit !== undefined && {
        has_profit: trade.hasProfit
      }),
      entry_time: trade.openTime || new Date().toISOString(),
      // Add exit_time after entry_time for completed trades
      ...(trade.status !== "active" && trade.closeTime && {
        exit_time: trade.closeTime
      }),
      events: jsonEvents
    };
    
    return position;
  });
  
  return {
    wallet_address: walletAddress,
    sync_timestamp: new Date().toISOString(),
    positions
  };
}

// Add after the existing getPositionEvents function, before the fetchTransactionWithRetry function

/**
 * PARALLEL VERSION - Process multiple PDAs concurrently for faster execution
 * This version can be 2-3x faster than the sequential version
 */
export async function getPositionEventsParallel(fromDateString?: string, walletAddress?: string, toDateString?: string) {
  if (!walletAddress) {
    throw new Error("Wallet address is required");
  }
  const wallet = walletAddress;
  
  // Generate all possible position PDAs for the wallet
  const positionPdas = generateAllPositionPdas(wallet);
  
  // Parse dates
  const fromDate = fromDateString 
    ? parseDate(fromDateString)
    : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  
  const toDate = toDateString 
    ? parseDate(toDateString)
    : new Date();
  
  // Validate date range
  if (fromDate >= toDate) {
    throw new Error(`FROM_DATE (${fromDate.toLocaleDateString('en-GB')}) must be older than TO_DATE (${toDate.toLocaleDateString('en-GB')})`);
  }

  // Position event filter - extracted to avoid duplication
  const POSITION_EVENT_NAMES = new Set([
    "IncreasePositionEvent",
    "InstantIncreasePositionEvent", 
    "DecreasePositionEvent",
    "InstantDecreasePositionEvent",
    "LiquidateFullPositionEvent",
    "IncreasePositionPreSwapEvent",
    "DecreasePositionPostSwapEvent",
    "InstantCreateTpslEvent",
    "InstantUpdateTpslEvent",
    "FillLimitOrderEvent"
  ]);

  // Process all PDAs in parallel (Jupiter has max 9 PDAs: 3 long + 6 short)
  // Using batches to respect RPC rate limits
  const CONCURRENCY_LIMIT = 5; // Process 5 PDAs simultaneously for optimal speed/reliability balance
  const results: any[] = [];
  
  for (let i = 0; i < positionPdas.length; i += CONCURRENCY_LIMIT) {
    const batch = positionPdas.slice(i, i + CONCURRENCY_LIMIT);
    
    const batchPromises = batch.map(pda => processPdaParallel(pda, fromDate, toDate));
    const batchResults = await Promise.all(batchPromises);
    
    results.push(...batchResults);
    
    // Brief delay between batches to prevent rate limiting
    if (i + CONCURRENCY_LIMIT < positionPdas.length) {
      await new Promise(resolve => setTimeout(resolve, 30));
    }
  }
  
  // Flatten all events from all PDAs
  const allEvents = results.flat();
  
  // Sort all events chronologically
  allEvents.sort((a, b) => {
    const aTime = a?.tx.blockTime ? new Date(a.tx.blockTime).getTime() : 0;
    const bTime = b?.tx.blockTime ? new Date(b.tx.blockTime).getTime() : 0;
    return aTime - bTime;
  });
  

  // Filter and return position events using Set for O(1) lookup performance
  return allEvents.filter(data => 
    data?.event?.name && POSITION_EVENT_NAMES.has(data.event.name)
  );
}

/**
 * Process a single PDA with parallel transaction processing
 */
async function processPdaParallel(currentPda: any, fromDate: Date, toDate: Date): Promise<any[]> {
  // Fetch all signatures for this PDA first
  const allSignatures = await fetchAllSignaturesParallel(currentPda, fromDate, toDate);
  
  if (allSignatures.length === 0) {
    return [];
  }

  // Process transactions in parallel batches with good concurrency for speed
  const TRANSACTION_BATCH_SIZE = 10; // Back to aggressive settings for v1 
  const allEvents: any[] = [];
  
  for (let i = 0; i < allSignatures.length; i += TRANSACTION_BATCH_SIZE) {
    const batch = allSignatures.slice(i, i + TRANSACTION_BATCH_SIZE);
    
    // Filter out failed transactions
    const validBatch = batch.filter(sig => !sig.err);
    
    if (validBatch.length === 0) continue;
    
    // Process this batch of transactions in parallel
    const batchPromises = validBatch.map(sigInfo => processTransactionParallel(sigInfo));
    const batchResults = await Promise.all(batchPromises);
    
    // Flatten and add to results
    const batchEvents = batchResults.flat().filter(Boolean);
    allEvents.push(...batchEvents);
    
    // Minimal delay for speed
    if (i + TRANSACTION_BATCH_SIZE < allSignatures.length) {
      await new Promise(resolve => setTimeout(resolve, 10)); // Reduced delay
    }
  }
  
  return allEvents;
}

/**
 * Fetch all signatures for a PDA with optimized batch processing
 */
async function fetchAllSignaturesParallel(currentPda: any, fromDate: Date, toDate: Date): Promise<any[]> {
  const allSignatures: any[] = [];
  let beforeSignature: string | undefined = undefined;
  let hasMoreTransactions = true;
  let totalFetched = 0;
  
  while (hasMoreTransactions && totalFetched < 2000) { // Increased limit for larger datasets
    const options: any = { limit: 1000 }; // Back to 1000 for speed - retries handle any issues
    if (beforeSignature) {
      options.before = beforeSignature;
    }
    
    const confirmedSignatureInfos = await getSignaturesWithRetry(currentPda.positionPda, options);

    if (!confirmedSignatureInfos || confirmedSignatureInfos.length === 0) {
      break;
    }
    
    totalFetched += confirmedSignatureInfos.length;
    
    // Check dates and filter
    for (const sigInfo of confirmedSignatureInfos) {
      const blockTime = sigInfo.blockTime ?? null;
      
      if (!shouldContinueFetching(blockTime, fromDate)) {
        hasMoreTransactions = false;
        break;
      }
      
      if (isWithinDateRange(blockTime, fromDate, toDate)) {
        allSignatures.push(sigInfo);
      }
    }
    
    // Set up for next batch
    if (hasMoreTransactions && confirmedSignatureInfos.length === 1000) {
      beforeSignature = confirmedSignatureInfos[confirmedSignatureInfos.length - 1].signature;
      // Minimal delay for speed
      await new Promise(resolve => setTimeout(resolve, 20)); // Reduced delay for speed
    } else {
      hasMoreTransactions = false;
    }
  }
  
  return allSignatures;
}

/**
 * Process a single transaction with all its events
 */
async function processTransactionParallel(sigInfo: any): Promise<any[]> {
  try {
    const tx = await fetchTransactionWithRetry(sigInfo.signature);
    
    if (!tx || !tx.meta || !tx.meta.innerInstructions) {
      return [];
    }
    
    const txEvents = tx.meta.innerInstructions.flatMap((ix: { instructions: any[] }) => {
      return ix.instructions.map((iix: { data: string }) => {
        try {
          const ixData = utils.bytes.bs58.decode(iix.data);
          const eventData = utils.bytes.base64.encode(
            ixData.subarray(DISCRIMINATOR_SIZE)
          );
          const decodedEvent = JUPITER_PERPETUALS_PROGRAM.coder.events.decode(eventData);
          
          const formattedEvent = formatEventData(decodedEvent);
          const feeInSOL = tx.meta!.fee / 1_000_000_000;
          
          const eventWithTx = {
            event: formattedEvent,
            tx: {
              signature: sigInfo.signature,
              blockTime: tx.blockTime 
                ? new Date(tx.blockTime * 1000).toISOString()
                : null,
              fee: `${feeInSOL} SOL`,
              feeInLamports: tx.meta!.fee
            }
          };
          
          // Handle TP/SL events (simplified for parallel processing)
          if (formattedEvent && (
              formattedEvent.name === 'InstantCreateTpslEvent' || 
              formattedEvent.name === 'InstantUpdateTpslEvent')
          ) {
            // Add basic TP/SL data extraction here if needed
            // For now, keeping it simple for performance
          }
          
          return eventWithTx;
        } catch (error) {
          return null;
        }
      }).filter(Boolean);
    });
    
    return txEvents;
  } catch (error) {
    return [];
  }
}